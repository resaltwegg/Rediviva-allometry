---
title: "Analysis for Melin et al: 'Allometric relationships shape foreleg evolution of long-legged oil bees (Melittidae: Rediviva)'"
author: "Annalie Melin, Res Altwegg, John C. Manning and Jonathan F. Colville"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  pdf_document:
    number_sections: TRUE
    toc: true
bibliography: rediviva.bib
csl: evolution.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, fig.path='Figs/')
```

```{r include = FALSE}
    
library(captioner)

fig_nums <- captioner(prefix = "Figure S", auto_space =F)

table_nums <- captioner(prefix = "Table S", auto_space =F)

# figure captions
fig.staticallometry <- fig_nums(name="staticallometry", caption = "Allometric relationship of leg length against body size in \\textit{Rediviva} species. The solid circles indicate the species means.")

fig.evolutionaryallometry <- fig_nums(name="evolutionaryallometry", caption = "Allometric relationship of leg length against body size in \\textit{Rediviva} species. The black line shows the fitted evolutionary allometric relationship.")

fig.evolutionaryallometry_withoutNeliana <- fig_nums(name="evolutionaryallometry_withoutNeliana", caption = "Allometric relationship of leg length against body size in \\textit{Rediviva} species, excluding \\textit{R. neliana}. The black line shows the fitted evolutionary allometric relationship.")

fig.withgigas <- fig_nums(name="withgigas", caption = "Allometric relationship of leg length against body size in \\textit{Rediviva} species, including \\textit{R. gigas}. The black line shows the fitted evolutionary allometric relationship.")

fig.ea_neliana <- fig_nums(name="ea_neliana", caption = "Allometric relationship of leg length against body size in \\textit{R. neliana} populations The black line shows the fitted evolutionary allometric relationship.")

fig.LegLengthSpurLength <- fig_nums(name="LegLengthSpurLength", caption = "Leg length of \\textit{Rediviva} individuals of different species against mean spur length of their host plant flowers. The solid black line is the 1:1 relationship. Colours indicate different species using the same colour scheme as in Figure S1.)")

fig.allometry_spurlength <- fig_nums(name="allometry_spurlength", caption = "Relationship of allometric intercept to spur length of the host plants for \\textit{Rediviva} bee species. The allometric intercept shown are the Best Linear Unbiased Predictors for the species-specific intercepts estimated by model m9. The regression line shows the fitted relationship from model m10.")

fig.allometry_spurlength_arithmetic <- fig_nums(name="allometry_spurlength_arithmetic", caption = "Relationship of allometric intercept (i.e. estimated species-specific leg length from Model m11) to spur length of the host plants for \\textit{Rediviva} bee species, fitted on the aritmetic scale.")

fig.LegLengthSpurLength_neliana <- fig_nums(name="LegLengthSpurLength_neliana", caption = "Leg length of \\textit{R. neliana} individuals from different populations against spur length of their host plant flowers. The solid black line is the 1:1 relationship. Colours indicate different populations using the same colour scheme as in Figure S5.)")

fig.allometry_spurlength_neliana <- fig_nums(name="allometry_spurlength_neliana", caption = "Relationship of allometric intercept to spur length of the host plants for \\textit{Rediviva neliana} populations. The allometric intercept shown are the Best Linear Unbiased Predictors for the population-specific intercepts estimated by model m9. The regression line shows the fitted relationship from model m10.")

fig.allometry_spurlength_arithmetic_neliana <- fig_nums(name="allometry_spurlength_arithmetic_neliana", caption = "Relationship of allometric intercept (i.e. estimated population-specific leg length from Model m11) to spur length of the host plants for \\textit{Rediviva neliana} populations, fitted on the aritmetic scale.")


# table captions
table.alloparms <- table_nums(name="alloparms", caption = 'Summary of morphological data and allometric parameters for 25 species of \\textit{Rediviva} bees. N: sample size (number of individuals); LegLength: mean total length of foreleg length [mm]; LL.SD: standard deviation of leg length; BodySize: inter-tegula distance as a measure of body size; BS.SD: standard deviation of body size; a and b: parameters a of the allometric relationships; lcl.a, ucl.a: lower and upper 95\\% confidence limits of parameter a; lcl.b, ucl.b: lower and upper 95\\% confidence limits of parameter b.')

table.delta <- table_nums(name="tabledelta", caption = 'Difference (delta) between the evolutionary and static allometric slopes estimated by three different models across \\textit{Rediviva} species. lcl and ucl are the lower and upper limits of the 95\\% confidence interval.')

table.delta.gigas <- table_nums(name="tabledelta.gigas", caption = 'Difference (delta) between the evolutionary and static allometric slopes estimated by three different models across \\textit{Rediviva} species including \\textit{R. gigas}. lcl and ucl are the lower and upper limits of the 95\\% confidence interval.')

table.allometries.n <- table_nums(name="allometries.n", caption = 'Summary of morphological data and allometric parameters for 10 populations of \\textit{R. neliana} bees. N: sample size (number of individuals per population); LegLength: mean total length of foreleg length [mm]; LL.SD: standard deviation of leg length; BodySize: inter-tegula distance as a measure of body size; BS.SD: standard deviation of body size; a and b are the parameters of the allometric relationships; lcl.a, ucl.a: lower and upper 95\\% confidence limits of parameter a; lcl.b, ucl.b: lower and upper 95\\% confidence limits of parameter b.')

table.delta.n <- table_nums(name="delta.n", caption = 'Difference (delta) between the evolutionary and static allometric slopes estimated by three different models across \\textit{R. neliana} populations. lcl and ucl are the lower and upper limits of the 95\\% confidence interval.')

table.intspur <- table_nums(name="intspur", caption = 'Relationship between the allometric intercept and spur length of the host flower for 18 species of \\textit{Rediviva} bees. Beta is the estimated slope of this relationship and the other columns give the lower and upper 95\\% confidence limits.')


table.slopespur <- table_nums(name="slopespur", caption = 'Relationship between the allometric slope and spur length of the host flower for 18 species of \\textit{Rediviva} bees. Beta is the estimated slope of this relationship and the other columns give the lower and upper 95\\% confidence limits.')

table.varratios <- table_nums(name="varratios", caption = 'Ratio of the variances in bee leg length and plant spur length')

table.varratios.n <- table_nums(name="varratios.n", caption = 'Ratio of the variances in bee leg length and plant spur length')

# figure captions
```

# Introduction

This document is an appendix to the paper 'Allometric relationships shape foreleg evolution of long-legged oil bees (Melittidae: Rediviva)' by Annalie Melin, Res Altwegg, John C. Manning and Jonathan F. Colville, detailing the statistical analyses presented there.

This study examines narrow-sense allometry of foreleg length in a group of oil-collecting bee species from South Africa. Narrow-sense allometry is defined as

\begin{equation}
Y = a \times X^b
\label{eq:allometry}
\end{equation}

where $Y$ is foreleg length, and $X$ is a linear measure of body size (inter-tegula distance) in our case. The allometric parameters $a$ and $b$ determine the shape of the allometric relationship.

On the log scale, the allometric power law becomes linear, $ln(Y) = ln(a) + b \times ln(X)$, and we can estimate the parameters $ln(a)$ and $b$ using linear regression techniques, where $ln(a)$ is estimated by the intercept and $b$ is estimated by the slope.

Different types of allometry are recognised. For us here, two are important: 1) *static allometry* is the allometric relationship measured within species across individuals at the same developmental state (adults in our case), and 2) *evolutionary allometry* is the allometric relationship measured across species.

# Data preparation

We'll need the following R packages:

```{r libs, message=F}
library(ape)
library(phylolm)
library(geiger)
library(nlme)
library(RColorBrewer)
```

```{r, include=F}
beemorph <- read.csv("Rediviva_allom_dataset.csv")
```

The data set consists of data on `r dim(beemorph)[1]` individual bees belonging to `r length(unique(beemorph$Taxa))` species in the genus *Rediviva*. Each row corresponds to an individual bee and the next two columns give total leg length and a linear measure of body size (inter-tegula distance). The column 'spur_length' contains the average spur length of the flowers of the plant species this particular bee species is known to visit For two species, *R.neliana* and *R.pallidula*, we have enough data to be able to distinguish between populations. The columns 'Taxa' and 'population_spur_length' identify the population an individual bee came from, for these two species, and the spur length of the flowers that they visit in these particular locations.

```{r dataprep}
beemorph <- read.csv("Rediviva_allom_dataset.csv")
summary(beemorph)
```

Create some variables that make life easier later:

```{r}
beemorph$log.leg <- log(beemorph$leg_length)
beemorph$log.body <- log(beemorph$body_size)
beemorph$Taxa <- as.factor(beemorph$Taxa)
beemorph$SPECIES.no <- as.numeric(beemorph$Taxa)
```

So we have measurements of leg length and body size for a number of individuals for each of 25 species of the genus *Rediviva* and want to estimate the parameters of the static allometric relationship and the evolutionary allometric relationship. The former is the ordinary linear regression line of log(leg length) on log(body size) **within** species and the latter is the same relationship **between** species .


# Estimating the parameters of the static allometric relationships for each species

In a first step, we examine the static allometry for each species, using maximum likelihood methods:

```{r}
m1 <- lm(log.leg ~ Taxa * log.body, data=beemorph)
anova(m1)
```

The ANOVA table above shows that there is variation among taxa in both the allometric intercept and the allometric slope even though the Mean Squares for the former was much larger than for the latter. The model explained `r round(summary(m1)$r.squared * 100, 1)`% of the variation in leg length.

We slightly re-parameterise Model `m1` above to estimate the parameters of the static allometry for each species directly and collect the parameter estimates with confidence intervals, from Model `m2`:

```{r}
m2 <- lm(log.leg ~ -1 + Taxa + Taxa:log.body, data=beemorph)
nspecies <- length(unique(beemorph$Taxa)) # the number of species we have
a <- exp(m2$coefficients[1:nspecies])
b <- m2$coefficients[(nspecies+1):(nspecies*2)]
allometries <- data.frame(cbind(a, b))
allometries$lcl.a <- exp(confint(m2)[1:nspecies,1])
allometries$ucl.a <- exp(confint(m2)[1:nspecies,2])
allometries$lcl.b <- confint(m2)[(nspecies +1):(nspecies*2),1]
allometries$ucl.b <- confint(m2)[(nspecies +1):(nspecies*2),2]
allometries$loga <- m2$coefficients[1:nspecies]
allometries$loga.se <- sqrt(diag(vcov(m2)))[1:nspecies]
allometries$b.se <- sqrt(diag(vcov(m2)))[(nspecies+1):(nspecies*2)]
```

The models above fitted separate allometric curves to each species, i.e. $ln(leg) = ln(a) + b \times ln(body)$. The slopes estimate $b$ for each species and exponentiating the intercepts estimates $a$ for each species. `r table_nums("alloparms", display = "cite")` below gives the parameter estimates with confidence intervals and `r fig_nums("staticallometry", display = "cite")` plots the fitted relationships.

The variance in slopes among species was `r round(var(allometries$b),4)` which is smaller than the mean of the squared standard error of the species-specific slope estimates, `r round(mean(allometries$b.se^2),4)`, suggesting that the variation in slopes is largely due to sampling variance.


```{r , echo=F}
rownames(allometries) <- substr(rownames(allometries), start=5, stop=100)
allometries$N <- aggregate(beemorph$leg_length,by=list(beemorph$Taxa),length)$x
allometries$LegLength <- aggregate(beemorph$leg_length,by=list(beemorph$Taxa),mean)$x
allometries$LL.SD <- aggregate(beemorph$leg_length,by=list(beemorph$Taxa),sd)$x
allometries$BodySize <- aggregate(beemorph$body_size,by=list(beemorph$Taxa),mean)$x
allometries$BS.SD <- aggregate(beemorph$body_size,by=list(beemorph$Taxa),sd)$x
```
\newpage

\begin{center}
`r table_nums("alloparms")`
\end{center}

```{r alloparms, echo=F, fig.cap=table_nums("alloparms")}
knitr::kable(allometries[,c(10:14, 1:6)], digits = 2)

```

```{r, echo=F, message=FALSE, results="hide"}
n <- length(levels(beemorph$Taxa))
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]  # gets all discrete color palettes from RColorBrewer
qual_col_pals <- qual_col_pals[c("Dark2", "Set1", "Set3"),]  # choosing 3 that look most different to me (we need 25 distinct colors!)
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

pdf("staticallometry.pdf")
par(mar=c(4,4,1,1))
plot(log.leg ~ log.body, data=beemorph, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph$log.body),max(beemorph$log.body)+0.35), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
mtext(expression ('log' * ' foreleg length'), side=2, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))
axis(2,las=1)


# plotting within-species (static) allometry
for (i in 1:max(beemorph$SPECIES.no)) lines(predict(m2)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph, col=col_vector[i])

points(aggregate(beemorph$log.body, by = list(beemorph$Taxa), FUN=mean)$x, 
       aggregate(beemorph$log.leg, by = list(beemorph$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

legend(1.5, 3.0, legend = levels(beemorph$Taxa), col=col_vector, bty="n", pch=19, cex=0.9, text.font=3)
dev.off()
```

```{r staticallometry, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("staticallometry.pdf")
```
\begin{center}
`r fig_nums("staticallometry")`
\end{center}

\newpage

# Comparing the static and evolutionary allometric relationships

In a next step, we want to estimate the evolutionary allometric relationship and compare it to the static allometric relationship. We also want to estimate the variance among species in the coefficients of their static allometric relationship. We use random effects to estimate these variances. 

We use multi-level models (also known as contextual models [@Heisler1987; @Egset2011]), to separately estimate the within-species and between-species slope, following van de Pol and Wright [-@VandePol2009]:

\begin{equation}
l_{ij} = \beta_0 + \beta_w (b_{ij} - b_{.j}) + \beta_b b_{.j} + \epsilon_{ij} 
\label{eq:allsame}
\end{equation}

where $l_{ij}$ is the logarithm of the leg length measurement of the $i^{th}$ individual of species $j$, $b_{ij}$
is the logarithm of the body size of that individual, $b_{.j}$ is the logarithm of the mean body size across all individuals of species $j$, $\beta_0$ is the intercept, $\beta_w$ is the within-species effect, i.e. the static allometric slope, $\beta_b$ is the between-species effect, i.e. the evolutionary allometric slope, and $\epsilon_{ij}$ are the residuals. The residuals are assumed to follow a normal distribution with a mean of zero and variances to be estimated.

The model in equation \ref{eq:allsame} assumes a common intercept and static allometric slope across all species. In the next model, we allow the intercept to vary among species by adding species random effects, $\mu_{0j}$. These random effects are assumed to follow a normal distribution with a mean of zero and variances to be estimated.

\begin{equation} 
l_{ij} = \beta_0 + \beta_w (b_{ij} - b_{.j}) + \beta_b b_{.j} + \mu_{0j} + \epsilon_{ij} 
\label{eq:varint}
\end{equation}

Next, we allow the static allometric slopes to vary among species by adding a random slope to Model \ref{eq:varint}:

\begin{equation} 
l_{ij} = (\beta_0 + \mu_{0j}) + (\beta_w + \mu_{wj})(b_{ij} - b_{.j}) + \beta_b b_{.j}  + \epsilon_{ij} 
\label{eq:varslope}
\end{equation}

The code chunk below calculates $b_{.j}$ and $b_{ij} - b_{.j}$:

```{r}
# calculate mean body size per species:
mean.body <- aggregate(beemorph$log.body, by = list(beemorph$Taxa), FUN=mean)  
colnames(mean.body) <- c("Taxa", "mean.body")

# add mean body size back onto data frame:
beemorph <- merge(beemorph, mean.body, by.x = "Taxa", by.y = "Taxa", all.x=T)  
# difference in body size within species:
beemorph$diff.body <- beemorph$log.body - beemorph$mean.body  
```

The evolutionary allometry describes how a trait scales with body size across species. From `r fig_nums("staticallometry", display = "cite")` it is clear that *R. gigas* is an outlier in that respect. This species has the largest body size in this data set but has average leg length. As it also is ecologically quite different from the other species, we exclude it from the main analysis but for completeness report results also with this species included.

```{r}
beemorph.r <- beemorph[beemorph$Taxa !="Rediviva gigas",]
beemorph.r$Taxa <- factor(beemorph.r$Taxa)
beemorph.r$SPECIES.no <- as.numeric(beemorph.r$Taxa)
```


We are now ready to fit the models:

```{r}
m3 <- lm(log.leg ~ diff.body + mean.body, data=beemorph.r) # static allometry same across species
summary(m3)

m4 <- lme(log.leg ~ diff.body + mean.body, random =~1|Taxa, data=beemorph.r) # random intercept
summary(m4)

m5 <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|Taxa, data=beemorph.r) 
   # random intercept and slope
summary(m5)
```

The residual standard error decreases markedly, from `r round(summary(m3)$sigma, 3)` in Model `m3` to `r round(sqrt(varcomp(m4)[[2]]),3)` in Model `m4`, when we included random intercepts. Including random slopes reduced the residual standard error to `r round(sqrt(varcomp(m5)[[2]]),3)` in Model `m5`. This is a relatively small reduction, which agrees with our earlier result that the variation in slopes among species is likely largely due to sampling variance. AIC favoured Model `m5` over Model `m4`, however (`r round(AIC(m5), 2)` compared to `r round(AIC(m4),2)`).


\newpage

```{r, echo=F, message=FALSE, results="hide"}
pdf("evolutionaryallometry.pdf",width = 14, height = 5)
par(mar=c(4,1,1,1), mfrow=c(1,4), oma=c(0,5,0,0))

# m3
plot(log.leg ~ log.body, data=beemorph.r, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.r$log.body),max(beemorph.r$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
mtext(expression ('log' * ' foreleg length'), side=2, line=2.4, outer=T)
axis(1, at=seq(0.8, 1.5, 0.2))
axis(2,las=1)

# plotting within-species (static) allometry
for (i in 1:max(beemorph.r$SPECIES.no)) lines(predict(m3)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.r, col=col_vector[i])

points(aggregate(beemorph.r$log.body, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       aggregate(beemorph.r$log.leg, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.r$log.body),max(beemorph.r$log.leg),length=50) # adding line for evolutionary allometry
y <- coefficients(m3)[1] + coefficients(m3)[3] * x
lines(y~x)


# m4
plot(log.leg ~ log.body, data=beemorph.r, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.r$log.body),max(beemorph.r$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph.r$SPECIES.no)) lines(predict(m4)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.r, col=col_vector[i])

points(aggregate(beemorph.r$log.body, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       aggregate(beemorph.r$log.leg, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.r$log.body),max(beemorph.r$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m4)[1] + fixef(m4)[3] * x
lines(y~x)

# m5
plot(log.leg ~ log.body, data=beemorph.r, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.r$log.body),max(beemorph.r$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph.r$SPECIES.no)) lines(predict(m5)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.r, col=col_vector[i])

points(aggregate(beemorph.r$log.body, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       aggregate(beemorph.r$log.leg, by = list(beemorph.r$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.r$log.body),max(beemorph.r$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m5)[1] + fixef(m5)[3] * x
lines(y~x)

# legend panel
plot(log.leg ~ log.body, data=beemorph.r,type='n',axes=F, ann=F)
legend(0.7, 3.0, legend = levels(beemorph.r$Taxa), col=col_vector, bty="n", pch=19, cex=1.2, text.font=3)

dev.off()
```

```{r evolutionaryallometry, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("evolutionaryallometry.pdf")
```
\begin{center}
`r fig_nums("evolutionaryallometry")`
\end{center}

Does the evolutionary allometric slope ($\beta_b$ in Equations \ref{eq:allsame} - \ref{eq:varslope}; `mean.body` in the R output above) differ from isometry? The estimates are `r round(coefficients(m3)[3],1)` (Model `m3`), `r round(summary(m4)$tTable[3,1],3)` (Model `m4`) and `r round(summary(m5)$tTable[3,1],3)` (Model `m5`). Do these estimates of $\beta_b$ differ from 1? We can easily test this for the estimates of $\beta_b$ from Models `m3` to `m5` against the null hypothesis $H_0: \beta_b = 1$.

```{r}
# m3
(tstat.m3 <-(coefficients(m3)[3]-1)/sqrt(vcov(m3)[3,3])) # t statistic
pt(tstat.m3,df=summary(m3)$df[2], lower.tail = F)*2 # p value (2-sided alternative)

# m4
(tstat.m4 <-(summary(m4)$tTable[3,1]-1)/summary(m4)$tTable[3,2]) # t statistic
pt(tstat.m4,df=summary(m4)$tTable[3,3], lower.tail = F)*2 # p value (2-sided alternative)

# m5
(tstat.m5 <-(summary(m5)$tTable[3,1]-1)/summary(m5)$tTable[3,2]) # t statistic
pt(tstat.m5,df=summary(m5)$tTable[3,3], lower.tail = F)*2 # p value (2-sided alternative)
```

According to Models `m3` and `m5`, the evolutionary allometric slope is significantly different from 1. In Model `m4`, $\beta_b$ was estimated with a large standard error, leading to a relatively high P value and weak evidence against $H_0$. We note that Model `m5` was best supported by the data and therefore conclude that --on balance -- the data support the notion that the evolutionary allometric slope is larger than 1.

What proportion of the between species variation in foreleg length is explained by the variation in mean body size between species? I.e. does the evolutionary allometric relationship examined above explain a large proportion of the variation in mean leg length? If it does, this would suggest that body size constrained the evolution of leg length. To examine this question, we re-fitted the model with random intercept (Equation \ref{eq:varint}) without entering mean body size as predictor.

\begin{equation} 
l_{ij} = \beta_0 + \beta_w (b_{ij} - b_{.j}) + \mu_{Tj} + \epsilon_{ij} 
\label{eq:varint_0}
\end{equation}

In this model, the variance of the random effects $\mu_{Tj}$ -- $\sigma^{2}_{Tj}$ -- estimates the total among-species variance in foreleg length whereas the variance of the random effects $\mu_{0j}$ (in Equation \ref{eq:varint}) -- $\sigma^2_{0j}$ -- estimates the among-species variance after accounting for mean body size. Comparing $\sigma^{2}_{Tj}$ to $\sigma^2_{0j}$, we can then estimate the proportion of among-species variance in foreleg length that is explained by species-specific body size:

$$\frac{\sigma^{2}_{Tj} - \sigma^2_{0j}}{\sigma^{2}_{Tj}}$$

```{r}
m4.T <- lme(log.leg ~ diff.body, random =~1|Taxa, data=beemorph.r) # random intercept
```

The variance of the random intercepts increased from `r round(as.numeric(varcomp(m4)[[1]]),3)` in Model `m4` to `r round(as.numeric(varcomp(m4.T)[[1]]),3)` in Model `m4.T` and mean body size therefore explained `r round(((varcomp(m4.T)[[1]] - varcomp(m4)[[1]])/varcomp(m4.T)[[1]])*100, 1)`% of the variance in the foreleg length among species.

## Variation in allometric parameters when *R. neliana* is excluded

*R. neliana* had the steepest static allometric relationship of all species and we are going to examine this species in more detail later. Here, we quickly want to check how much the estimated variation in static allometric slopes changes if we exclude this species.

```{r, echo=F, message=FALSE, results="hide"}
beemorph.rr <- beemorph.r[beemorph.r$Taxa !="Rediviva neliana",]
beemorph.rr$Taxa <- factor(beemorph.rr$Taxa)
beemorph.rr$SPECIES.no <- as.numeric(beemorph.rr$Taxa)

m3 <- lm(log.leg ~ diff.body + mean.body, data=beemorph.rr) # static allometry same across species

m4 <- lme(log.leg ~ diff.body + mean.body, random =~1|Taxa, data=beemorph.rr) # random intercept

m5 <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|Taxa, data=beemorph.rr) # random intercept and slope

pdf("evolutionaryallometry_withoutNeliana.pdf",width = 14, height = 5)
par(mar=c(4,1,1,1), mfrow=c(1,4), oma=c(0,5,0,0))

# m3
plot(log.leg ~ log.body, data=beemorph.rr, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.rr$log.body),max(beemorph.rr$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
mtext(expression ('log' * ' foreleg length'), side=2, line=2.4, outer=T)
axis(1, at=seq(0.8, 1.5, 0.2))
axis(2,las=1)

# plotting within-species (static) allometry
for (i in 1:max(beemorph.rr$SPECIES.no)) lines(predict(m3)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.rr, col=col_vector[i])

points(aggregate(beemorph.rr$log.body, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       aggregate(beemorph.rr$log.leg, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.rr$log.body),max(beemorph.rr$log.leg),length=50) # adding line for evolutionary allometry
y <- coefficients(m3)[1] + coefficients(m3)[3] * x
lines(y~x)


# m4
plot(log.leg ~ log.body, data=beemorph.rr, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.rr$log.body),max(beemorph.rr$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph.rr$SPECIES.no)) lines(predict(m4)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.rr, col=col_vector[i])

points(aggregate(beemorph.rr$log.body, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       aggregate(beemorph.rr$log.leg, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.rr$log.body),max(beemorph.rr$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m4)[1] + fixef(m4)[3] * x
lines(y~x)

# m5
plot(log.leg ~ log.body, data=beemorph.rr, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph.rr$log.body),max(beemorph.rr$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph.rr$SPECIES.no)) lines(predict(m5)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph.rr, col=col_vector[i])

points(aggregate(beemorph.rr$log.body, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       aggregate(beemorph.rr$log.leg, by = list(beemorph.rr$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph.rr$log.body),max(beemorph.rr$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m5)[1] + fixef(m5)[3] * x
lines(y~x)

# legend panel
plot(log.leg ~ log.body, data=beemorph.rr,type='n',axes=F, ann=F)
legend(0.8, 3.0, legend = levels(beemorph.rr$Taxa), col=col_vector, bty="n", pch=19, cex=1.2, text.font=3)

dev.off()
```

Re-running the analyses in the previous section without *R. neliana*, we obtained qualitatively similar results. The residual standard error decreases markedly, from `r round(summary(m3)$sigma, 3)` in Model `m3` to `r round(sqrt(varcomp(m4)[[2]]),3)` in Model `m4`, when we included random intercepts. Including random slopes reduced the residual standard error to `r round(sqrt(varcomp(m5)[[2]]),3)` in Model `m5` (`r fig_nums("evolutionaryallometry_withoutNeliana", display = "cite")`). The variance in slopes among species was `r round(var(allometries$b[-which(rownames(allometries)=="Rediviva neliana")]),4)` which is smaller than the mean of the squared standard error of the species-specific slope estimates, `r round(mean(allometries$b.se[-which(rownames(allometries)=="Rediviva neliana")]^2),4)`, suggesting that the variation in slopes is largely due to sampling variance.

```{r evolutionaryallometry_withoutNeliana, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("evolutionaryallometry_withoutNeliana.pdf")
```

\begin{center}
`r fig_nums("evolutionaryallometry_withoutNeliana")`
\end{center}


# Testing whether static and evolutionary allometric slopes differ

We reparameterised the multi-level model in Equations \ref{eq:allsame} to \ref{eq:varslope} to allow us to directly test whether the evolutionary allometric slope differs from the (mean) static allometric slope [@VandePol2009]:

\begin{equation}
l_{ij} = \beta_0 + \beta_w b_{ij} + (\beta_b - \beta_w) b_{.j} + \epsilon_{ij} 
\label{eq:allsame_c}
\end{equation}

\begin{equation} 
l_{ij} = \beta_0 + \beta_w b_{ij} + (\beta_b - \beta_w) b_{.j} + \mu_{0j} + \epsilon_{ij} 
\label{eq:varint_c}
\end{equation}

\begin{equation} 
l_{ij} = (\beta_0 + \mu_{0j}) + (\beta_w + \mu_{wj})b_{ij} + (\beta_b - \beta_w) b_{.j}  + \epsilon_{ij} 
\label{eq:varslope_c}
\end{equation}

The models are very similar to the ones in Equations \ref{eq:allsame} to \ref{eq:varslope} except that we include the individual body size measures instead of the difference to the species mean. This way, the coefficient for species-specific mean body size estimates the difference between the evolutionary and static allometric slopes (see van de Pol and Wright [-@VandePol2009] for details).

```{r}
m6 <- lm(log.leg ~ log.body + mean.body, data=beemorph.r) # static allometry same across species

m7 <- lme(log.leg ~ log.body + mean.body, random =~1|Taxa, data=beemorph.r) # random intercept

m8 <- lme(log.leg ~ log.body + mean.body, random =~diff.body|Taxa, data=beemorph.r) 
  # random intercept and slope
```

Note that Models `m6` to `m8` are just reparameterisations of models `m3` to `m5` and thus identical to those in terms of their fit to the data. The estimated difference between the evolutionary and static allometric slopes (delta $=\beta_b - \beta_w$) with confidence intervals are shown in `r table_nums("tabledelta", display = "cite")`

\begin{center}
`r table_nums("tabledelta")`
\end{center}

````{r tabledelta, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tab <- data.frame(Model = c('m6', 'm7', 'm8'), delta = c(coefficients(m6)[3], intervals(m7)$fixed[3,2], intervals(m8)$fixed[3,2]), lcl = c(confint(m6)[3,1], intervals(m7)$fixed[3,1], intervals(m8)$fixed[3,1]), ucl = c(confint(m6)[3,2], intervals(m7)$fixed[3,3], intervals(m8)$fixed[3,3]))

knitr::kable(tab, digits = 2)
```

The coefficient estimating the difference between the evolutionary and static allometric slopes is positive, indicating that the evolutionary allometric slope is steeper than the static allometric slope. The estimates broadly agree across models but Model `m7` yielded a wide confidence interval that included 0.

\pagebreak

# Do these results change when we include *R. gigas*?

*R. gigas* was a clear outlier in the general relationship between body size and leg length across species and we therefore excluded *R. gigas* above. Here, we repeat the analysis with *R. gigas* included.


```{r, echo=F, message=FALSE, results="hide"}

m3 <- lm(log.leg ~ diff.body + mean.body, data=beemorph) # static allometry same across species
m4 <- lme(log.leg ~ diff.body + mean.body, random =~1|Taxa, data=beemorph) # random intercept
m5 <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|Taxa, data=beemorph) # random intercept and slope

# m3
(tstat.m3 <-(coefficients(m3)[3]-1)/sqrt(vcov(m3)[3,3])) # t statistic

# m4
(tstat.m4 <-(summary(m4)$tTable[3,1]-1)/summary(m4)$tTable[3,2]) # t statistic

# m5
(tstat.m5 <-(summary(m5)$tTable[3,1]-1)/summary(m5)$tTable[3,2]) # t statistic
```

We refit Models `m3` to `m5` to test whether the evolutionary allometric slope differs from isometry. The estimated evolutionary slopes, i.e. $\beta_b$, are now `r round(coefficients(m3)[3],3)` (se = `r round(sqrt(vcov(m3)[3,3]),3)`, t = `r round(tstat.m3,3)`, P = `r round(pt(tstat.m3,df=summary(m3)$df[2], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m3`, `r round(summary(m4)$tTable[3,1],3)` (se = `r round(summary(m4)$tTable[3,2],3)`, t = `r round(tstat.m4,3)`, P = `r round(pt(tstat.m4,df=summary(m4)$tTable[3,3], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m4` and `r round(summary(m5)$tTable[3,1],3)` (se = `r round(summary(m5)$tTable[3,2],3)`, t = `r round(tstat.m5,3)`, P = `r round(pt(tstat.m5,df=summary(m5)$tTable[3,3], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m5`. Only Model `m3`, which was poorly supported by the data, suggests some evidence against $H_0$ and therefore conclude that --on balance -- when including *R. gigas*, we have no clear evidence that the evolutionary allometric slope differs from 1.

We re-fitted models `m6` to `m8` including *R. gigas* and `r table_nums("tabledelta.gigas", display = "cite")` below gives the estimated difference between the evolutionary and static allometric slopes (delta $=\beta_b - \beta_w$) with confidence intervals.

```{r, echo=F}
m6 <- lm(log.leg ~ log.body + mean.body, data=beemorph) # static allometry same across species

m7 <- lme(log.leg ~ log.body + mean.body, random =~1|Taxa, data=beemorph) # random intercept

m8 <- lme(log.leg ~ log.body + mean.body, random =~diff.body|Taxa, data=beemorph) # random intercept and slope
```
\begin{center}
`r table_nums("tabledelta.gigas")`
\end{center}

````{r tabledelta.gigas, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tab <- data.frame(Model = c('m6', 'm7', 'm8'), delta = c(coefficients(m6)[3], intervals(m7)$fixed[3,2], intervals(m8)$fixed[3,2]), lcl = c(confint(m6)[3,1], intervals(m7)$fixed[3,1], intervals(m8)$fixed[3,1]), ucl = c(confint(m6)[3,2], intervals(m7)$fixed[3,3], intervals(m8)$fixed[3,3]))

knitr::kable(tab, digits = 2)
```

Including *R. gigas*, the analysis still suggested that the evolutionary allometric slope is steeper than the static allometric slope but the difference was smaller and the confidence interval overlapped zero for Models `m7` and `m8`. In conclusion, including the outlier species *R. gigas* affects the results presented earlier, albeit not the general pattern. `r fig_nums("withgigas", display = "cite")` below shows, however, that the fitted evolutionary allometric line is a poor description of the general relationship between log body size and log leg length across species. 

```{r, echo=F, message=FALSE, results="hide"}
pdf("evolutionaryallometry_withgigas.pdf",width = 14, height = 5)
par(mar=c(4,1,1,1), mfrow=c(1,4), oma=c(0,5,0,0))

# m3
plot(log.leg ~ log.body, data=beemorph, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph$log.body),max(beemorph$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
mtext(expression ('log' * ' foreleg length'), side=2, line=2.4, outer=T)
axis(1, at=seq(0.8, 1.5, 0.2))
axis(2,las=1)

# plotting within-species (static) allometry
for (i in 1:max(beemorph$SPECIES.no)) lines(predict(m3)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph, col=col_vector[i])

points(aggregate(beemorph$log.body, by = list(beemorph$Taxa), FUN=mean)$x, 
       aggregate(beemorph$log.leg, by = list(beemorph$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph$log.body),max(beemorph$log.leg),length=50) # adding line for evolutionary allometry
y <- coefficients(m3)[1] + coefficients(m3)[3] * x
lines(y~x)


# m4
plot(log.leg ~ log.body, data=beemorph, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph$log.body),max(beemorph$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph$SPECIES.no)) lines(predict(m4)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph, col=col_vector[i])

points(aggregate(beemorph$log.body, by = list(beemorph$Taxa), FUN=mean)$x, 
       aggregate(beemorph$log.leg, by = list(beemorph$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph$log.body),max(beemorph$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m4)[1] + fixef(m4)[3] * x
lines(y~x)

# m5
plot(log.leg ~ log.body, data=beemorph, col=col_vector[SPECIES.no], axes=F, 
     xlim=c(min(beemorph$log.body),max(beemorph$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
axis(1, at=seq(0.8, 1.5, 0.2))

# plotting within-species (static) allometry
for (i in 1:max(beemorph$SPECIES.no)) lines(predict(m5)[SPECIES.no==i] ~ log.body[SPECIES.no==i], data=beemorph, col=col_vector[i])

points(aggregate(beemorph$log.body, by = list(beemorph$Taxa), FUN=mean)$x, 
       aggregate(beemorph$log.leg, by = list(beemorph$Taxa), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for species means

x <- seq(min(beemorph$log.body),max(beemorph$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m5)[1] + fixef(m5)[3] * x
lines(y~x)

# legend panel
plot(log.leg ~ log.body, data=beemorph,type='n',axes=F, ann=F)
legend(0.7, 3.0, legend = levels(beemorph$Taxa), col=col_vector, bty="n", pch=19, cex=1.2, text.font=3)

dev.off()
```


```{r withgigas, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("evolutionaryallometry_withgigas.pdf")
```
\begin{center}
`r fig_nums("withgigas")`
\end{center}

\newpage

# Does accounting for phylogeny affect our results?

Our analyses above assumed independent residuals but clearly, the species are phylogenetically related and this relatedness could cause non-independence in the data. Our maximum likelihood estimates of the parameters of the static allometric relationships in `r table_nums("alloparms", display = "cite")` should not be affected because we estimated separate parameters for each species. However, our estimate of the evolutionary allometric parameters could be affected. In this section, we therefore re-run some key models while accounting for phylogenetic non-independence. We do not have complete phylogenetic information for all species examined so far, so this re-analysis is based on a reduced set of species, which is the main reason why we did not include phylogeny throughout.

A phylogeny published by Kahnt et al [-@kahnt2017playing] included most of the species in our sample. The code chunk below reads the tree and renames the tips so that the species names match those in the data frame. We drop *R. gigas* from the phylogenetic tree:


```{r}
beetree <- read.tree("Rediviva simplified treeUSE.nex")
beetree$tip.label <- gsub("Rediviva_", "Rediviva ", beetree$tip.label)

beetree.r <- drop.tip(beetree, c("Rediviva gigas")) ## drop R. gigas

plot(beetree.r)

beetree.r$tip.label <- gsub(" ", "", beetree.r$tip.label) # remove spaces in species names

```


There are seven species in our morphological data set that don't appear in the phylogeny and we remove all observations of these species:


```{r}
species.remove <- c("Rediviva autumnalis", "Rediviva pallidula", "Rediviva rhodosoma", 
                    "Rediviva ruficornis", "Rediviva rufocincta", "Rediviva transkeiana", 
                    "Rediviva whiteheadi")

beemorph.phy <- beemorph.r[!beemorph.r$Taxa %in% species.remove,]

```

Our data set contains multiple individuals per species and we therefore need to add tips to the phylogenetic tree:

```{r}
beemorph.phy$species <- gsub(" ", "", beemorph.phy$Taxa)
rownames(beemorph.phy) <- gsub(" ", "", paste0(beemorph.phy$species, 1:NROW(beemorph.phy)))

species <- unique(beemorph.phy$species)

## because there are multiple rows per species:
nice.tree.multi <- beetree.r
for (g in 1:NROW(species)){
  if(!is.null(nice.tree.multi$edge.length)){
    flat.tree <-  read.tree(text = 
      paste0("(", paste(rownames(beemorph.phy)[grep(species[g],rownames(beemorph.phy))], 
                        collapse = ":0.02, "), ":0.02);"))
  } else {
    flat.tree <-  read.tree(text = 
      c("(", paste(rownames(beemorph.phy)[grep(species[g], rownames(beemorph.phy))], 
                   collapse = ", "), ");"))
  }
  
  nice.tree.multi <- bind.tree(nice.tree.multi, flat.tree, 
                     where = which(nice.tree.multi$tip.label == species[g]), 
                     position = 0, interactive = FALSE)
  }

```

```{r, echo=F}
m3 <- lm(log.leg ~ diff.body + mean.body, data=beemorph.r) # static allometry same across species
m4 <- lme(log.leg ~ diff.body + mean.body, random =~1|Taxa, data=beemorph.r) # random intercept
m5 <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|Taxa, data=beemorph.r) 
   # random intercept and slope
```


Next, we use phylogenetic generalized least squares models. We first add phylogenetic model structures to the errors using model `m3`, which is the simplest multi-level model without random effects:


```{r}
m3.bm <- phylolm(log.leg ~ diff.body + mean.body, phy = nice.tree.multi, model = "BM", 
                 data = beemorph.phy)
summary(m3.bm)
m3.OUr <- phylolm(log.leg ~ diff.body + mean.body, phy = nice.tree.multi, model = "OUrandomRoot", 
                  data = beemorph.phy)
summary(m3.OUr)
m3.OUf <- phylolm(log.leg ~ diff.body + mean.body, phy = nice.tree.multi, model = "OUfixedRoot", 
                  data = beemorph.phy)
summary(m3.OUf)
m3.lambda <- phylolm(log.leg ~ diff.body + mean.body, phy = nice.tree.multi, model = "lambda", 
                     data = beemorph.phy)
summary(m3.lambda)
```


AIC suggests that the best model structure is the one assuming an Ornstein-Uhlenbeck process (Models `m3.OUr` and `m3.OUf`). However, all models return a similar estimate for the evolutionary allometric slope ($\beta_b$ in Equation \ref{eq:allsame} and `mean.body` in the output above ranged from `r round(coefficients(m3.OUf)[3],3)` to `r round(coefficients(m3.bm)[3],3)`), which is also comparable to the slope that was estimated by the model without phylogenetic structure (`m3`: `r round(coefficients(m3)[3],3)`) in an earlier section. 

We saw earlier, however, that Model `m3` was not a good description of our data. We next add a phylogenetic correlation structure to Models `m4` and `m5`. These models include random effects and are more complex statistical models. We only managed to get the models assuming a Brownian Motion process to converge.


```{r, cache=T}
m4.bm <- lme(log.leg ~ diff.body + mean.body, random =~1|Taxa, data=beemorph.phy, 
             correlation = corBrownian(1, nice.tree.multi)) 
summary(m4.bm)

m5.bm <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|Taxa, data=beemorph.phy, 
             correlation = corBrownian(1, nice.tree.multi)) 
summary(m5.bm)

```


Again, the estimated evolutionary allometric slopes were  similar to the ones obtained earlier from the models assuming no phylogenetic dependence structure: `r round(summary(m4.bm)$tTable[3,1],3)` in Model `m4.bm` compared to `r round(summary(m4)$tTable[3,1],3)` in Model `m4` and `r round(summary(m5.bm)$tTable[3,1],3)` in Model `m5.bm` compared to `r round(summary(m5)$tTable[3,1],3)` in Model `m5`. We conclude that our earlier results were not sensitive to violation of the assumption that the errors were phylogenetically independent.

# Estimating the parameters of the static allometric relationships for each population in *R. neliana*

We saw earlier that *R. neliana* had a steeper allometric slope than the other species. Is it possible that our *R. neliana* sample is made up of individuals that belong to several isolated populations on independent evolutionary tracks? In this section, we examine variation within and between populations of *R. neliana*. For this section, we refer to the within-population allometric relationship as the static allometric relationship and to the between-population allometric relationship as the evolutionary allometric relationship.

We first select the *R. neliana* individuals from the full data set and tabulate them by population:

```{r}
beemorph.n <- beemorph[beemorph$Taxa =="Rediviva neliana", c(2,3,5:8)]
beemorph.n$population_code <- factor(beemorph.n$population_code)
beemorph.n$pop.no <- as.numeric(beemorph.n$population_code)
table(beemorph.n$population_code)
```

Following identical procedures as above, we first estimate the static allometric relationship for each population separately:

```{r}
m1.n <- lm(log.leg ~ population_code * log.body, data=beemorph.n)
anova(m1.n)
```

The ANOVA table above shows that there is variation among populations in both the allometric intercept and the allometric slope even though the Mean Squares for the former was much larger than for the latter. The model explained `r round(summary(m1.n)$r.squared * 100, 1)`% of the variation in leg length. `r table_nums("allometries.n", display = "cite")` shows the maximum likelihood estimates for the parameters $a$ and $b$ (Equation \ref{eq:allometry}) of the population-specific allometric relationships.

```{r, echo=F}
m2 <- lm(log.leg ~ -1 + population_code + population_code:log.body, data=beemorph.n)
nspecies <- length(unique(beemorph.n$population_code)) # the number of populations we have
a <- exp(m2$coefficients[1:nspecies])
b <- m2$coefficients[(nspecies+1):(nspecies*2)]
allometries.n <- data.frame(cbind(a, b))
allometries.n$lcl.a <- exp(confint(m2)[1:nspecies,1])
allometries.n$ucl.a <- exp(confint(m2)[1:nspecies,2])
allometries.n$lcl.b <- confint(m2)[(nspecies +1):(nspecies*2),1]
allometries.n$ucl.b <- confint(m2)[(nspecies +1):(nspecies*2),2]
allometries.n$loga <- m2$coefficients[1:nspecies]
allometries.n$loga.se <- sqrt(diag(vcov(m2)))[1:nspecies]
allometries.n$b.se <- sqrt(diag(vcov(m2)))[(nspecies+1):(nspecies*2)]

rownames(allometries.n) <- substr(rownames(allometries.n), start=16, stop=100)

allometries.n$N <- aggregate(beemorph.n$leg_length,by=list(beemorph.n$population_code),length)$x
allometries.n$LegLength <- aggregate(beemorph.n$leg_length,by=list(beemorph.n$population_code),mean)$x
allometries.n$LL.SD <- aggregate(beemorph.n$leg_length,by=list(beemorph.n$population_code),sd)$x
allometries.n$BodySize <- aggregate(beemorph.n$body_size,by=list(beemorph.n$population_code),mean)$x
allometries.n$BS.SD <- aggregate(beemorph.n$body_size,by=list(beemorph.n$population_code),sd)$x
```

The variance in slopes among populations was `r round(var(allometries.n$b),4)` which is not much larger than the mean of the squared standard error of the population-specific slope estimates `r round(mean(allometries.n$b.se^2),4)` suggesting that the variation in slopes is largely due to sampling variance. 

\begin{center}
`r table_nums("allometries.n")`
\end{center}

```{r, echo=F}
knitr::kable(allometries.n[,c(10:14, 1:6)], digits = 2)

```


We fit the models described in equations \ref{eq:allsame} to \ref{eq:varslope} to the *R. neliana* data:

```{r, echo=F}
mean.body <- aggregate(beemorph.n$log.body, by = list(beemorph.n$population_code), FUN=mean)  # calculate mean body size per species
colnames(mean.body) <- c("population_code", "mean.body")

beemorph.n <- merge(beemorph.n, mean.body, by.x = "population_code", by.y = "population_code", all.x=T)  # add mean body size back onto data frame
beemorph.n$diff.body <- beemorph.n$log.body - beemorph.n$mean.body  # difference in body size within species
```

```{r}
m3.n <- lm(log.leg ~ diff.body + mean.body, data=beemorph.n) # static allometry same across species
summary(m3.n)

m4.n <- lme(log.leg ~ diff.body + mean.body, random =~1|population_code, data=beemorph.n) 
   # random intercept
summary(m4.n)

m5.n <- lme(log.leg ~ diff.body + mean.body, random =~diff.body|population_code, data=beemorph.n) 
   # random intercept and slope
summary(m5.n)
```

The residual standard error decreased markedly, from `r round(summary(m3.n)$sigma,3)` in Model `m3.n` to `r round(sqrt(varcomp(m4.n)[[2]]),3)` in Model `m4.n`, when we included random intercepts. Including random slopes reduced the residual standard error to `r round(sqrt(varcomp(m5.n)[[2]]),3)` in Model `m5.n`. This is a relatively small reduction, which agrees with our earlier result that the variation in slopes among species is likely largely due to sampling variance. AIC favoured Model `m5` over Model `m4`, however (`r round(AIC(m5.n), 2)` compared to `r round(AIC(m4.n),2)`).


```{r, echo=F, message=FALSE, results="hide"}
# m3
(tstat.m3 <-(coefficients(m3.n)[3]-1)/sqrt(vcov(m3.n)[3,3])) # t statistic

# m4
(tstat.m4 <-(summary(m4.n)$tTable[3,1]-1)/summary(m4.n)$tTable[3,2]) # t statistic

# m5
(tstat.m5 <-(summary(m5.n)$tTable[3,1]-1)/summary(m5.n)$tTable[3,2]) # t statistic
```

Using the fitted Models `m3.n` to `m5.n`, we test whether the evolutionary allometric slope differs from isometry. The estimated evolutionary slopes, i.e. $\beta_b$, are `r round(coefficients(m3.n)[3],3)` (se = `r round(sqrt(vcov(m3.n)[3,3]),3)`, t = `r round(tstat.m3,3)`, P = `r round(pt(tstat.m3,df=summary(m3.n)$df[2], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m3.n`, `r round(summary(m4.n)$tTable[3,1],3)` (se = `r round(summary(m4.n)$tTable[3,2],3)`, t = `r round(tstat.m4,3)`, P = `r round(pt(tstat.m4,df=summary(m4.n)$tTable[3,3], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m4.n` and `r round(summary(m5.n)$tTable[3,1],3)` (se = `r round(summary(m5.n)$tTable[3,2],3)`, t = `r round(tstat.m5,3)`, P = `r round(pt(tstat.m5,df=summary(m5.n)$tTable[3,3], lower.tail = F)*2,3)` testing $H_0: \beta_b = 1$) for Model `m5.n`. Only Model `m5.n`, which was poorly supported by the data, suggests some evidence against $H_0$ and we therefore conclude that we have no strong evidence that the evolutionary allometric slope among populations of *R. neliana* differs from 1.

We next examined $R^2$ for the evolutionary allometric relationship as we did in the between-species comparison earlier. 

```{r}
m4.T.n <- lme(log.leg ~ diff.body, random =~1|population_code, data=beemorph.n) # random intercept
```

The variance of the random intercepts increased from `r round(as.numeric(varcomp(m4.n)[[1]]),3)` in Model `m4.n` to `r round(as.numeric(varcomp(m4.T.n)[[1]]),3)` in Model `m4.T.n` and mean body size therefore explained `r round(((varcomp(m4.T.n)[[1]] - varcomp(m4.n)[[1]])/varcomp(m4.T.n)[[1]])*100, 1)`% of the variance in the foreleg length among species.

```{r, echo=F, message=FALSE, results="hide"}
pdf("evolutionaryallometry_neliana.pdf",width = 12, height = 5)
par(mar=c(4,1,1,1), mfrow=c(1,3), oma=c(0,5,0,0))

# m3
plot(log.leg ~ log.body, data=beemorph.n, col=col_vector[pop.no], axes=F, 
     xlim=c(min(beemorph.n$log.body),max(beemorph.n$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
mtext(expression ('log' * ' foreleg length'), side=2, line=2.4, outer=T)
axis(1, at=seq(0.6, 1.2, 0.2))
axis(2,las=1)

# plotting within-population (static) allometry
for (i in 1:max(beemorph.n$pop.no)) lines(predict(m3.n)[pop.no==i] ~ log.body[pop.no==i], data=beemorph.n, col=col_vector[i])

points(aggregate(beemorph.n$log.body, by = list(beemorph.n$population_code), FUN=mean)$x, 
       aggregate(beemorph.n$log.leg, by = list(beemorph.n$population_code), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for population means

x <- seq(min(beemorph.n$log.body),max(beemorph.n$log.leg),length=50) # adding line for evolutionary allometry
y <- coefficients(m3.n)[1] + coefficients(m3.n)[3] * x
lines(y~x)


# m4
plot(log.leg ~ log.body, data=beemorph.n, col=col_vector[pop.no], axes=F, 
     xlim=c(min(beemorph.n$log.body),max(beemorph.n$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
#mtext(expression ('log' * ' foreleg length'), side=2, line=2.4)
axis(1, at=seq(0.6, 1.2, 0.2))
#axis(2,las=1)

# plotting within-population (static) allometry
for (i in 1:max(beemorph.n$pop.no)) lines(predict(m4.n)[pop.no==i] ~ log.body[pop.no==i], data=beemorph.n, col=col_vector[i])

points(aggregate(beemorph.n$log.body, by = list(beemorph.n$population_code), FUN=mean)$x, 
       aggregate(beemorph.n$log.leg, by = list(beemorph.n$population_code), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for population means

x <- seq(min(beemorph.n$log.body),max(beemorph.n$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m4.n)[1] + fixef(m4.n)[3] * x
lines(y~x)

# m5
plot(log.leg ~ log.body, data=beemorph.n, col=col_vector[pop.no], axes=F, 
     xlim=c(min(beemorph.n$log.body),max(beemorph.n$log.body)), xlab = "", ylab = "")
mtext(expression ('log' * ' body size (ITD)'), side=1, line=2.4)
#mtext(expression ('log' * ' foreleg length'), side=2, line=2.4)
axis(1, at=seq(0.6, 1.2, 0.2))
#axis(2,las=1)

# plotting within-population (static) allometry
for (i in 1:max(beemorph.n$pop.no)) lines(predict(m5.n)[pop.no==i] ~ log.body[pop.no==i], data=beemorph.n, col=col_vector[i])

points(aggregate(beemorph.n$log.body, by = list(beemorph.n$population_code), FUN=mean)$x, 
       aggregate(beemorph.n$log.leg, by = list(beemorph.n$population_code), FUN=mean)$x, 
       pch=19, cex=2, col=col_vector) # adding dots for population means

x <- seq(min(beemorph.n$log.body),max(beemorph.n$log.leg),length=50) # adding line for evolutionary allometry
y <- fixef(m5.n)[1] + fixef(m5.n)[3] * x
lines(y~x)

legend(1.03, 2.13, legend = levels(beemorph.n$population_code), col=col_vector, bty="n", pch=19, cex=1.2, text.font=3)

dev.off()
```

```{r ea_neliana, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("evolutionaryallometry_neliana.pdf")
```
\begin{center}
`r fig_nums("ea_neliana")`
\end{center}

As we saw when comparing evolutionary and static allometry across species, the allometric slope is steeper among populations than within. Is this difference statistically supported?

The coefficient estimating the difference between the evolutionary and static allometric slopes was positive (`r table_nums("delta.n", display = "cite")`), indicating that the evolutionary allometric slope is steeper than the static allometric slope but the difference is much smaller than in the comparison across species and Models `m7` and `m8` both yielded a confidence interval that included 0.

In summary, when examining within- and among-population allometric relationships in *R. neliana*, we found qualitatively similar patterns as we did when examining within- and among-species allometric relationship across the *Rediviva* genus but these patterns were weaker and not always statistically supported.

\begin{center}
`r table_nums("delta.n")`
\end{center}

```{r delta.n, echo=F, results='asis'}
m6 <- lm(log.leg ~ log.body + mean.body, data=beemorph.n) # static allometry same across species

m7 <- lme(log.leg ~ log.body + mean.body, random =~1|population_code, data=beemorph.n) # random intercept

m8 <- lme(log.leg ~ log.body + mean.body, random =~diff.body|population_code, data=beemorph.n) # random intercept and slope

tab <- data.frame(Model = c('m6', 'm7', 'm8'), delta = c(coefficients(m6)[3], intervals(m7)$fixed[3,2], intervals(m8)$fixed[3,2]), lcl = c(confint(m6)[3,1], intervals(m7)$fixed[3,1], intervals(m8)$fixed[3,1]), ucl = c(confint(m6)[3,2], intervals(m7)$fixed[3,3], intervals(m8)$fixed[3,3]))

knitr::kable(tab, digits = 2)
```

# Is variation in allometric relationships explained by spur length of the host flowers?

For all species except *R. neliana*, the allometric exponent (slope) was estimated to be smaller than one. And when we considered within-population allometry for *R. neliana*, this was also true for all populations of that species. An allometric exponent $<1$ implies that small individuals have relatively long legs for their size and large individuals have relatively short legs for their size. What are the selective forces acting on this relationship and what could explain the variation among species -- and in the case of *R. neliana*, variation among population -- in these allometric parameters?

These bees collect oil from flowers using their forelegs, so spur length of the flowers from which these bees collect the oil is a candidate environmental driver likely to act as selective force. We generated a list of oil host plants for each *Rediviva* species, combined this with spur length data and calculated a mean spur length across all host plants per bee species.

`r fig_nums("LegLengthSpurLength", display = "cite")` shows leg length as a function of spur length (using a weighted mean across all plant species each bee species is known to visit). *R. gigas* is included in this plot. Leg length tracks spur length with most species having legs that are longer than the spur length of the flowers they visit.

```{r, echo=F, message=FALSE, results="hide"}
pdf("LegLengthSpurLength.pdf",6,5)
plot(leg_length ~ spur_length, data=beemorph, col=col_vector[SPECIES.no], axes=F, xlab="Spur length [mm]", ylab="Leg length [mm]")
axis(1)
axis(2, las=1)
abline(0,1)
dev.off()
```

```{r LegLengthSpurLength, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("LegLengthSpurLength.pdf")
```

\begin{center}
`r fig_nums("LegLengthSpurLength")`
\end{center}

We slightly re-parameterise the model described in Equation \ref{eq:varint} by subtracting the overall mean log body size ($\beta_{..}$) from the species-specific mean log body size ($\beta_{.j}$) so that the intercept estimates the log leg length for a bee of average log body size.

\begin{equation} 
l_{ij} = (\beta_0 + \mu_{0j}) + \beta_w (b_{ij} - b_{.j}) + \beta_b (b_{.j}-b_{..})  + \epsilon_{ij} 
\label{eq:varslope_i}
\end{equation}

We then add log spur length, $s$, as an explanatory variable to this model:

\begin{equation} 
l_{ij} = (\beta_0 + \mu_{rj}) + \beta_w (b_{ij} - b_{.j}) + \beta_b (b_{.j}-b_{..})  + \beta_s s + \epsilon_{ij} 
\label{eq:varslope_spur}
\end{equation}

Spur length varies among species and the random effects $\mu_{rj}$ in Equation \ref{eq:varslope_spur} therefore estimate the remaining variation among species in the allometric intercept after accounting for variation in spur length.

We estimate the proportion of variance of the allometric intercept that is explained by spur length as:

$$\frac{\sigma^2_{0j} - \sigma^2_{rj}}{\sigma^2_{rj}}$$

where $\sigma^2_{0j}$ is the estimated variance of the random effects $\mu_{0j}$ and $\sigma^2_{rj}$ is the estimated variance of the random effects $\mu_{rj}$. We excluded *R. gigas* from this analysis because this species was an outlier with a large influence on the estimated evolutionary allometric relationship.


```{r}
m9 <- lme(log.leg ~ diff.body + I(mean.body-mean(log.body)), random =~1|Taxa, data=beemorph.r) # random intercept and slope
summary(m9)

m10 <- lme(log.leg ~ diff.body + I(mean.body-mean(log.body)) + log(spur_length+0.5), 
           random =~1|Taxa, data=beemorph.r) # adding spur length
summary(m10)
```

There was strong evidence that leg length was positively related to spur length `r fig_nums("allometry_spurlength", display = "cite")` and variance of the random intercepts decreased from `r round(as.numeric(varcomp(m9)[[1]]),3)` in Model `m9` to `r round(as.numeric(varcomp(m10)[[1]]),3)` in Model `m10`. Spur length therefore explained `r round(((varcomp(m9)[[1]] - varcomp(m10)[[1]])/varcomp(m9)[[1]])*100, 1)`% of the variance in the intercept among species.

```{r, echo=F, message=FALSE, results="hide"}
allometries$spur_length <- aggregate(beemorph$spur_length, by=list(beemorph$Taxa), mean)$x

allometries.g <- allometries[-which(rownames(allometries)=="Rediviva gigas"),] # excluding gigas
allometries.g$SPECIES.no <- as.numeric(as.factor(rownames(allometries.g)))

allometries.g$blupintercepts <- fixef(m9)[1] + ranef(m9)[,1]

pdf("allometry_spurlength.pdf", 6,4.5)
op <- par(mfrow=c(1,2))

plot(blupintercepts ~ log(spur_length+0.5), data=allometries.g, col=col_vector[SPECIES.no], axes=F, xlab="log(Spur length [mm] + 0.5)", ylab="log(Allometric intercept)", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m10)[1], fixef(m10)[4])

plot(b ~ spur_length, data=allometries.g,type='n',axes=F, ann=F)
legend(0,1, legend = levels(as.factor(rownames(allometries.g))), col=col_vector, bty="n", pch=19, cex=0.5, text.font=3)

dev.off()
```

```{r allometry_spurlength, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("allometry_spurlength.pdf")
```
\begin{center}
`r fig_nums("allometry_spurlength")`
\end{center}

So far, we analysed narrow-sense allometry as a power law (Equation \ref{eq:allometry}) and we used log-transformed values for body size, leg length and spur length. An argument could be made that selection on leg length through variation in spur length follows arithmetic relationships instead: 1 mm change in spur length should trigger a 1 mm response in leg length. We therefore re-fitted Model m10 on the arithmetic scale:

\begin{equation} 
l^a_{ij} = (\beta_0 + \mu_{rj}) + \beta_w (b^a_{ij} - b^a_{.j}) + \beta_b (b^a_{.j}-b^a_{..})  + \beta_s s^a + \epsilon_{ij} 
\label{eq:varslope_spur_a}
\end{equation}

The superscripts $^a$ indicate that these variables were on the arithmetic scale, rather than the logarithmic scale used so far.

```{r}
# calculate mean body size per species on arithmetic scale:
mean.body.a <- aggregate(beemorph.r$body_size, by = list(beemorph.r$Taxa), FUN=mean)  
colnames(mean.body.a) <- c("Taxa", "mean.body.a")

# add mean body size back onto data frame:
beemorph.r <- merge(beemorph.r, mean.body.a, by.x = "Taxa", by.y = "Taxa", all.x=T)  

# difference in body size within species:
beemorph.r$diff.body.a <- beemorph.r$body_size - beemorph.r$mean.body.a  

m11 <- lme(leg_length ~ diff.body.a + I(mean.body.a-mean(body_size)) + spur_length, 
           random =~1|Taxa, data=beemorph.r) # adding spur length
summary(m11)

# testing whether the effect of spur length is different from 1
tstat.m11 <-(summary(m11)$tTable[4,1]-1)/summary(m11)$tTable[4,2] # t statistic
p.spur <- pt(tstat.m11,df=summary(m11)$tTable[4,3], lower.tail = T)*2 # p value (2-sided alternative)
```

In this analysis, the coefficient for spur length is easier to interpret: it estimates the change in leg length in millimeters, for every millimeter change in spur length. If leg length tracked spur length perfectly, we would expect this coefficient to be close to 1. However, the estimated effect was `r round(summary(m11)$tTable[4,1], 2)`, which is considerably less than 1 ($t=`r round(tstat.m11, 2)`, P = `r round(p.spur, 5)`$, `r fig_nums("allometry_spurlength_arithmetic", display = "cite")`).

```{r, echo=F, message=FALSE, results="hide"}
# Model m11 without spur length, for calculating variance explained by spur length
m11a <- lme(leg_length ~ diff.body.a + I(mean.body.a-mean(body_size)), random =~1|Taxa, data=beemorph.r) 
```

Comparing the variance of the random intercepts in Model m11 to an equivalent model without spur length, we find that spur length explained `r round(((varcomp(m11a)[[1]] - varcomp(m11)[[1]])/varcomp(m11a)[[1]])*100, 1)`% of the variance in the intercept among species when analysing allometry on the arithmetic scale.

```{r, echo=F, message=FALSE, results="hide"}
allometries.g$blupintercepts.a <- fixef(m11a)[1] + ranef(m11a)[,1]

pdf("allometry_spurlength_arithmetic.pdf", 6,4.5)
op <- par(mfrow=c(1,2))

plot(blupintercepts.a ~ spur_length, data=allometries.g, col=col_vector[SPECIES.no], axes=F, xlab="Spur length [mm]", ylab="Allometric intercept", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m11)[1], fixef(m11)[4])

plot(b ~ spur_length, data=allometries.g,type='n',axes=F, ann=F)
legend(0,1, legend = levels(as.factor(rownames(allometries.g))), col=col_vector, bty="n", pch=19, cex=0.5, text.font=3)

dev.off()
```

```{r allometry_spurlength_arithmetic, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("allometry_spurlength_arithmetic.pdf")
```
\begin{center}
`r fig_nums("allometry_spurlength_arithmetic")`
\end{center}

# Is allometric variation among *R. neliana* populations explained by spur length of the host flowers?

We next apply the analyses of the section above to *R. neliana* and examine whether variation in the allometric parameters among populations is related to spur length of the population-specific host plants.

`r fig_nums("LegLengthSpurLength_neliana", display = "cite")` shows leg length as a function of spur length. Leg length tracks spur length reasonably well across populations.

```{r, echo=F, message=FALSE, results="hide"}
pdf("LegLengthSpurLength_neliana.pdf", 6, 5)
plot(exp(log.leg) ~ population_spur_length, data=beemorph.n, col=col_vector[pop.no], axes=F, xlab="Spur length [mm]", ylab="Leg length [mm]")
axis(1)
axis(2, las=1)
abline(0,1)
dev.off()
```

```{r LegLengthSpurLength_neliana, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("LegLengthSpurLength_neliana.pdf")
```
\begin{center}
`r fig_nums("LegLengthSpurLength_neliana")`
\end{center}


```{r}
m9.n <- lme(log.leg ~ diff.body + I(mean.body-mean(log.body)), random =~1|population_code,
          data=beemorph.n) # random intercepts and slopes
summary(m9.n)
m10.n <- lme(log.leg ~ diff.body + I(mean.body-mean(log.body)) + log(population_spur_length+0.5), 
           random =~1|population_code, data=beemorph.n) # adding spur length
summary(m10.n)
```

The variance of the random intercepts decreased from `r round(as.numeric(varcomp(m9.n)[[1]]),3)` in Model `m9` to `r round(as.numeric(varcomp(m10.n)[[1]]),3)` in Model `m10` and spur length therefore explained `r round(((varcomp(m9.n)[[1]] - varcomp(m10.n)[[1]])/varcomp(m9.n)[[1]])*100, 1)`% of the variance in the intercept among species. The relationship between intercepts and spur length was strongly positive (`r fig_nums("allometry_spurlength_neliana", display = "cite")`).


```{r, echo=F, message=FALSE, results="hide"}
allometries.n$population_spur_length <- aggregate(beemorph.n$population_spur_length, by=list(beemorph.n$population_code), mean)$x

allometries.n$population_code <- as.numeric(as.factor(rownames(allometries.n)))

allometries.n$blupintercepts <- fixef(m9.n)[1] + ranef(m9.n)[,1]

pdf("allometry_spurlength_neliana.pdf", 6,4.5)
op <- par(mfrow=c(1,2))

plot(blupintercepts ~ log(population_spur_length+0.5), data=allometries.n, col=col_vector[population_code], axes=F, xlab="log(Spur length [mm] + 0.5)", ylab="log(Allometric intercept)", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m10.n)[1], fixef(m10.n)[4])

plot(blupintercepts ~ log(population_spur_length+0.5), data=allometries.n,type='n',axes=F, ann=F)
legend(1.8,2.3, legend = levels(as.factor(rownames(allometries.n))), col=col_vector[allometries.n$population_code], bty="n", pch=19, cex=0.9, text.font=3)

dev.off()
```


```{r allometry_spurlength_neliana, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("allometry_spurlength_neliana.pdf")
```
\begin{center}
`r fig_nums("allometry_spurlength_neliana")`
\end{center}

```{r, echo=T}
# calculate mean body size per population on arithmetic scale:
mean.body.a <- aggregate(exp(beemorph.n$log.body), by = list(beemorph.n$population_code), FUN=mean)  
colnames(mean.body.a) <- c("Taxa", "mean.body.a")

# add mean body size back onto data frame:
beemorph.n <- merge(beemorph.n, mean.body.a, by.x = "population_code", by.y = "Taxa", all.x=T)  
# difference in body size within species:
beemorph.n$diff.body.a <- exp(beemorph.n$log.body) - beemorph.n$mean.body.a  

m11.n <- lme(exp(log.leg) ~ diff.body.a + I(mean.body.a-mean(body_size)) + population_spur_length, 
           random =~1|population_code, data=beemorph.n) # adding spur length
summary(m11.n)

# testing whether the effect of spur length is different from 1
tstat.m11 <-(summary(m11.n)$tTable[4,1]-1)/summary(m11.n)$tTable[4,2] # t statistic
p.spur <- pt(tstat.m11,df=summary(m11.n)$tTable[4,3], lower.tail = T)*2 # p value (2-sided alternative)
```

As for the between-species comparison, we re-fitted the multi-level model (Equation \ref{eq:varslope_spur_a}) to leg length and body length on the arithmetic scale. If leg length tracked spur length perfectly, we would expect this coefficient to be close to 1 on this scale. However, the estimated effect was `r round(summary(m11.n)$tTable[4,1], 2)`, which is considerably less than 1 ($t=`r round(tstat.m11, 2)`, P = `r round(p.spur, 5)`$, `r fig_nums("allometry_spurlength_arithmetic_neliana", display = "cite")`).

```{r, echo=F, message=FALSE, results="hide"}
# Model m11 without spur length, for calculating variance explained by spur length
m11a.n <- lme(exp(log.leg) ~ diff.body.a + I(mean.body.a-mean(body_size)), random =~1|population_code, data=beemorph.n)
```

Comparing the variance of the random intercepts in Model m11 to an equivalent model without spur length, we find that spur length explained `r round(((varcomp(m11a.n)[[1]] - varcomp(m11.n)[[1]])/varcomp(m11a.n)[[1]])*100, 1)`% of the variance in the intercept among populations when analysing allometry on the arithmetic scale.

```{r, echo=F, message=FALSE, results="hide"}
allometries.n$blupintercepts.a <- fixef(m11a.n)[1] + ranef(m11a.n)[,1]

pdf("allometry_spurlength_arithmetic_neliana.pdf", 6,4.5)
op <- par(mfrow=c(1,2))

plot(blupintercepts.a ~ population_spur_length, data=allometries.n, col=col_vector[population_code], axes=F, xlab="Spur length [mm]", ylab="Allometric intercept", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m11.n)[1], fixef(m11.n)[4])

plot(blupintercepts ~ log(population_spur_length+0.5), data=allometries.n,type='n',axes=F, ann=F)
legend(1.8,2.3, legend = levels(as.factor(rownames(allometries.n))), col=col_vector[allometries.n$population_code], bty="n", pch=19, cex=0.9, text.font=3)

dev.off()
```

```{r allometry_spurlength_arithmetic_neliana, out.width="\\linewidth", include=TRUE, fig.align="center", echo=F}
knitr::include_graphics("allometry_spurlength_arithmetic_neliana.pdf")
```
\begin{center}
`r fig_nums("allometry_spurlength_arithmetic_neliana")`
\end{center}

```{r, echo=F, message=FALSE, results="hide"}
# This code chunk produces figure 4 for the paper
#################################################

pdf("Fig4_paper.pdf", 6,6)
op <- par(mfrow=c(2,3))

plot(blupintercepts ~ log(spur_length+0.5), data=allometries.g, col=col_vector[SPECIES.no], axes=F, xlab="log(Spur length [mm] + 0.5)", ylab="log(Allometric intercept)", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m10)[1], fixef(m10)[4])
text(-0.5, 2.65, "a)")

plot(blupintercepts.a ~ spur_length, data=allometries.g, col=col_vector[SPECIES.no], axes=F, xlab="Spur length [mm]", ylab="Allometric intercept", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m11)[1], fixef(m11)[4])
text(1, 16, "b)")

plot(b ~ spur_length, data=allometries.g,type='n',axes=F, ann=F)
legend(0,1, legend = levels(as.factor(rownames(allometries.g))), col=col_vector, bty="n", pch=19, cex=0.5, text.font=3)

plot(blupintercepts ~ log(population_spur_length+0.5), data=allometries.n, col=col_vector[population_code], axes=F, xlab="log(Spur length [mm] + 0.5)", ylab="log(Allometric intercept)", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m10.n)[1], fixef(m10.n)[4])
text(1.8, 2.3, "c)")

plot(blupintercepts.a ~ population_spur_length, data=allometries.n, col=col_vector[population_code], axes=F, xlab="Spur length [mm]", ylab="Allometric intercept", pch=19)
axis(1)
axis(2, las=1)
abline(fixef(m11.n)[1], fixef(m11.n)[4])
text(6, 10, "d)")

plot(blupintercepts ~ log(population_spur_length+0.5), data=allometries.n,type='n',axes=F, ann=F)
legend(1.8,2.3, legend = levels(as.factor(rownames(allometries.n))), col=col_vector[allometries.n$population_code], bty="n", pch=19, cex=0.9, text.font=3)

dev.off()
```

# References
